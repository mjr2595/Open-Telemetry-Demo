import { ContextManager, Context } from '@opentelemetry/context-base';
export declare abstract class AbstractAsyncHooksContextManager implements ContextManager {
    abstract active(): Context;
    abstract with<T extends (...args: unknown[]) => ReturnType<T>>(context: Context, fn: T): ReturnType<T>;
    abstract enable(): this;
    abstract disable(): this;
    bind<T>(target: T, context?: Context): T;
    private _bindFunction;
    /**
     * By default, EventEmitter call their callback with their context, which we do
     * not want, instead we will bind a specific context to all callbacks that
     * go through it.
     * @param target EventEmitter a instance of EventEmitter to patch
     * @param context the context we want to bind
     */
    private _bindEventEmitter;
    /**
     * Patch methods that remove a given listener so that we match the "patched"
     * version of that listener (the one that propagate context).
     * @param ee EventEmitter instance
     * @param original reference to the patched method
     */
    private _patchRemoveListener;
    /**
     * Patch methods that remove all listeners so we remove our
     * internal references for a given event.
     * @param ee EventEmitter instance
     * @param original reference to the patched method
     */
    private _patchRemoveAllListeners;
    /**
     * Patch methods on an event emitter instance that can add listeners so we
     * can force them to propagate a given context.
     * @param ee EventEmitter instance
     * @param original reference to the patched method
     * @param [context] context to propagate when calling listeners
     */
    private _patchAddListener;
}
//# sourceMappingURL=AbstractAsyncHooksContextManager.d.ts.map