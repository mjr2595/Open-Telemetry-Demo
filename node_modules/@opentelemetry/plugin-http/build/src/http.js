"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.plugin = exports.HttpPlugin = void 0;
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const api_1 = require("@opentelemetry/api");
const core_1 = require("@opentelemetry/core");
const semver = require("semver");
const shimmer = require("shimmer");
const url = require("url");
const utils = require("./utils");
const version_1 = require("./version");
/**
 * Http instrumentation plugin for Opentelemetry
 */
class HttpPlugin extends core_1.BasePlugin {
    constructor(moduleName, version) {
        super(`@opentelemetry/plugin-${moduleName}`, version_1.VERSION);
        this.moduleName = moduleName;
        this.version = version;
        this._emptySpanContext = {
            traceId: '',
            spanId: '',
            traceFlags: api_1.TraceFlags.NONE,
        };
        // For now component is equal to moduleName but it can change in the future.
        this.component = this.moduleName;
        this._spanNotEnded = new WeakSet();
        this._config = {};
    }
    /** Patches HTTP incoming and outcoming request functions. */
    patch() {
        this._logger.debug('applying patch to %s@%s', this.moduleName, this.version);
        shimmer.wrap(this._moduleExports, 'request', this._getPatchOutgoingRequestFunction());
        // In Node >=8, http.get calls a private request method, therefore we patch it
        // here too.
        if (semver.satisfies(this.version, '>=8.0.0')) {
            shimmer.wrap(this._moduleExports, 'get', this._getPatchOutgoingGetFunction(this._moduleExports.request));
        }
        if (this._moduleExports &&
            this._moduleExports.Server &&
            this._moduleExports.Server.prototype) {
            shimmer.wrap(this._moduleExports.Server.prototype, 'emit', this._getPatchIncomingRequestFunction());
        }
        else {
            this._logger.error('Could not apply patch to %s.emit. Interface is not as expected.', this.moduleName);
        }
        return this._moduleExports;
    }
    /** Unpatches all HTTP patched function. */
    unpatch() {
        shimmer.unwrap(this._moduleExports, 'request');
        if (semver.satisfies(this.version, '>=8.0.0')) {
            shimmer.unwrap(this._moduleExports, 'get');
        }
        if (this._moduleExports &&
            this._moduleExports.Server &&
            this._moduleExports.Server.prototype) {
            shimmer.unwrap(this._moduleExports.Server.prototype, 'emit');
        }
    }
    /**
     * Creates spans for incoming requests, restoring spans' context if applied.
     */
    _getPatchIncomingRequestFunction() {
        return (original) => {
            return this._incomingRequestFunction(original);
        };
    }
    /**
     * Creates spans for outgoing requests, sending spans' context for distributed
     * tracing.
     */
    _getPatchOutgoingRequestFunction() {
        return (original) => {
            return this._outgoingRequestFunction(original);
        };
    }
    _getPatchOutgoingGetFunction(clientRequest) {
        return (_original) => {
            // Re-implement http.get. This needs to be done (instead of using
            // getPatchOutgoingRequestFunction to patch it) because we need to
            // set the trace context header before the returned ClientRequest is
            // ended. The Node.js docs state that the only differences between
            // request and get are that (1) get defaults to the HTTP GET method and
            // (2) the returned request object is ended immediately. The former is
            // already true (at least in supported Node versions up to v10), so we
            // simply follow the latter. Ref:
            // https://nodejs.org/dist/latest/docs/api/http.html#http_http_get_options_callback
            // https://github.com/googleapis/cloud-trace-nodejs/blob/master/src/plugins/plugin-http.ts#L198
            return function outgoingGetRequest(options, ...args) {
                const req = clientRequest(options, ...args);
                req.end();
                return req;
            };
        };
    }
    /**
     * Attach event listeners to a client request to end span and add span attributes.
     *
     * @param request The original request object.
     * @param options The arguments to the original function.
     * @param span representing the current operation
     */
    _traceClientRequest(request, options, span) {
        var _a;
        const hostname = options.hostname || ((_a = options.host) === null || _a === void 0 ? void 0 : _a.replace(/^(.*)(:[0-9]{1,5})/, '$1')) ||
            'localhost';
        const attributes = utils.getOutgoingRequestAttributes(options, {
            component: this.component,
            hostname,
        });
        span.setAttributes(attributes);
        if (this._config.requestHook) {
            this._callRequestHook(span, request);
        }
        request.on('response', (response) => {
            const attributes = utils.getOutgoingRequestAttributesOnResponse(response, { hostname });
            span.setAttributes(attributes);
            if (this._config.responseHook) {
                this._callResponseHook(span, response);
            }
            api_1.context.bind(response);
            this._logger.debug('outgoingRequest on response()');
            response.on('end', () => {
                this._logger.debug('outgoingRequest on end()');
                let status;
                if (response.aborted && !response.complete) {
                    status = { code: api_1.StatusCode.ERROR };
                }
                else {
                    status = utils.parseResponseStatus(response.statusCode);
                }
                span.setStatus(status);
                if (this._config.applyCustomAttributesOnSpan) {
                    this._safeExecute(span, () => this._config.applyCustomAttributesOnSpan(span, request, response), false);
                }
                this._closeHttpSpan(span);
            });
            response.on('error', (error) => {
                utils.setSpanWithError(span, error, response);
                this._closeHttpSpan(span);
            });
        });
        request.on('close', () => {
            if (!request.aborted) {
                this._closeHttpSpan(span);
            }
        });
        request.on('error', (error) => {
            utils.setSpanWithError(span, error, request);
            this._closeHttpSpan(span);
        });
        this._logger.debug('_traceClientRequest return request');
        return request;
    }
    _incomingRequestFunction(original) {
        const plugin = this;
        return function incomingRequest(event, ...args) {
            // Only traces request events
            if (event !== 'request') {
                return original.apply(this, [event, ...args]);
            }
            const request = args[0];
            const response = args[1];
            const pathname = request.url
                ? url.parse(request.url).pathname || '/'
                : '/';
            const method = request.method || 'GET';
            plugin._logger.debug('%s plugin incomingRequest', plugin.moduleName);
            if (utils.isIgnored(pathname, plugin._config.ignoreIncomingPaths, (e) => plugin._logger.error('caught ignoreIncomingPaths error: ', e))) {
                return api_1.context.with(api_1.suppressInstrumentation(api_1.context.active()), () => {
                    api_1.context.bind(request);
                    api_1.context.bind(response);
                    return original.apply(this, [event, ...args]);
                });
            }
            const headers = request.headers;
            const spanOptions = {
                kind: api_1.SpanKind.SERVER,
                attributes: utils.getIncomingRequestAttributes(request, {
                    component: plugin.component,
                    serverName: plugin._config.serverName,
                }),
            };
            return api_1.context.with(api_1.propagation.extract(api_1.ROOT_CONTEXT, headers), () => {
                const span = plugin._startHttpSpan(`HTTP ${method}`, spanOptions);
                return api_1.context.with(api_1.setSpan(api_1.context.active(), span), () => {
                    api_1.context.bind(request);
                    api_1.context.bind(response);
                    if (plugin._config.requestHook) {
                        plugin._callRequestHook(span, request);
                    }
                    if (plugin._config.responseHook) {
                        plugin._callResponseHook(span, response);
                    }
                    // Wraps end (inspired by:
                    // https://github.com/GoogleCloudPlatform/cloud-trace-nodejs/blob/master/src/plugins/plugin-connect.ts#L75)
                    const originalEnd = response.end;
                    response.end = function (..._args) {
                        response.end = originalEnd;
                        // Cannot pass args of type ResponseEndArgs,
                        const returned = plugin._safeExecute(span, () => response.end.apply(this, arguments), true);
                        const attributes = utils.getIncomingRequestAttributesOnResponse(request, response);
                        span
                            .setAttributes(attributes)
                            .setStatus(utils.parseResponseStatus(response.statusCode));
                        if (plugin._config.applyCustomAttributesOnSpan) {
                            plugin._safeExecute(span, () => plugin._config.applyCustomAttributesOnSpan(span, request, response), false);
                        }
                        plugin._closeHttpSpan(span);
                        return returned;
                    };
                    return plugin._safeExecute(span, () => original.apply(this, [event, ...args]), true);
                });
            });
        };
    }
    _outgoingRequestFunction(original) {
        const plugin = this;
        return function outgoingRequest(options, ...args) {
            if (!utils.isValidOptionsType(options)) {
                return original.apply(this, [options, ...args]);
            }
            const extraOptions = typeof args[0] === 'object' &&
                (typeof options === 'string' || options instanceof url.URL)
                ? args.shift()
                : undefined;
            const { origin, pathname, method, optionsParsed } = utils.getRequestInfo(options, extraOptions);
            if (utils.isIgnored(origin + pathname, plugin._config.ignoreOutgoingUrls, (e) => plugin._logger.error('caught ignoreOutgoingUrls error: ', e))) {
                return original.apply(this, [optionsParsed, ...args]);
            }
            const operationName = `HTTP ${method}`;
            const spanOptions = {
                kind: api_1.SpanKind.CLIENT,
            };
            const span = plugin._startHttpSpan(operationName, spanOptions);
            if (!optionsParsed.headers) {
                optionsParsed.headers = {};
            }
            api_1.propagation.inject(api_1.setSpan(api_1.context.active(), span), optionsParsed.headers);
            const request = plugin._safeExecute(span, () => original.apply(this, [optionsParsed, ...args]), true);
            plugin._logger.debug('%s plugin outgoingRequest', plugin.moduleName);
            api_1.context.bind(request);
            return plugin._traceClientRequest(request, optionsParsed, span);
        };
    }
    _startHttpSpan(name, options) {
        /*
         * If a parent is required but not present, we use a `NoRecordingSpan` to still
         * propagate context without recording it.
         */
        const requireParent = options.kind === api_1.SpanKind.CLIENT
            ? this._config.requireParentforOutgoingSpans
            : this._config.requireParentforIncomingSpans;
        let span;
        const currentSpan = api_1.getSpan(api_1.context.active());
        if (requireParent === true && currentSpan === undefined) {
            // TODO: Refactor this when a solution is found in
            // https://github.com/open-telemetry/opentelemetry-specification/issues/530
            span = new core_1.NoRecordingSpan(exports.plugin._emptySpanContext);
        }
        else if (requireParent === true && (currentSpan === null || currentSpan === void 0 ? void 0 : currentSpan.context().isRemote)) {
            span = currentSpan;
        }
        else {
            span = this._tracer.startSpan(name, options);
        }
        this._spanNotEnded.add(span);
        return span;
    }
    _closeHttpSpan(span) {
        if (!this._spanNotEnded.has(span)) {
            return;
        }
        span.end();
        this._spanNotEnded.delete(span);
    }
    _callResponseHook(span, response) {
        this._safeExecute(span, () => this._config.responseHook(span, response), false);
    }
    _callRequestHook(span, request) {
        this._safeExecute(span, () => this._config.requestHook(span, request), false);
    }
    _safeExecute(span, execute, rethrow) {
        try {
            return execute();
        }
        catch (error) {
            if (rethrow) {
                utils.setSpanWithError(span, error);
                this._closeHttpSpan(span);
                throw error;
            }
            this._logger.error('caught error ', error);
        }
    }
}
exports.HttpPlugin = HttpPlugin;
exports.plugin = new HttpPlugin('http', process.versions.node);
//# sourceMappingURL=http.js.map